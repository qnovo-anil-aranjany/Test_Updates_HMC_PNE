"""This main test module serves as an indicator for TAF to trigger pytest, executing all test cases in this tst
directory. Additionally, it sets up necessary imports and parameters for other test modules in this 'tst' directory to
leverage."""

import ast
import csv
from os.path import abspath, dirname, join
from pathlib import Path

import cffi
import numpy as np
import pytest
import random
from pytest import fixture, mark, param
from src.common import (
    PROJECT_PATH,
    clean_dat_files,
    compare_result,
    get_lib_callables,
    invoke_pytest,
    lib,
    lib_array_to_list,
    log_stack_parametrized_inputs,
    parametrize_args,
    read_json_results,
    record_test_data,
    set_lib_inputs,
    size,
    validate_test_cases,
    write_json_results,
    iter_file,
    validate_with_reference_data,
    write_output_to_csv,
)
from typing import Any, Dict, List, Tuple


MAKE_HTML = True  # Set true to allow html report generation.

ffi = cffi.FFI()
_MODULE_PATH = abspath(__file__)
_TIME_BASED_INPUT_DATA = "test_data\\time_based_data\\input_data"
_TIME_BASED_OUTPUT_DATA = "test_data\\time_based_data\\output_data"
_TIME_BASED_REFERENCE_DATA = "test_data\\time_based_data\\reference_data"
_TOTAL_BYTES = 18

warning_map = {
    0: "AFC_No_Warnings",
    1: "Warn_AFC_InputsNotReady",
    2: "Warn_AFC_NVMInitFailed",
    3: "Warn_AFC_ExceedChgCurrRange",
    4: "Warn_AFC_ExceedTempRange",
    5: "Warn_AFC_ChgCapacityZero",
    6: "Warn_AFC_ExceedMaxStage",
    7: "Warn_AFC_OverSADVoltLim",
    8: "Warn_AFC_OverSafetyVoltLim",
    9: "Warn_AFC_OverCvVoltLim",
    10: "Warn_AFC_CPVIdxOutOfRange",
    11: "Warn_AFC_TuningLimOOR",
    12: "Warn_AFC_EarlyWarnAging",
    13: "Warn_AFC_AbnormalAging",
    14: "Warn_AFC_ExtremeAging",
}

@fixture(scope="function")
def setup_parameters(lib) -> None:
    """This fixture initializes the global variables in the specified library module at the beginning of each test
    function. These variables are reset to their initial values for every standard and parametrized test case, ensuring
    consistent test conditions.

    Args:
        lib (module): The shared library module, either a .dll (Windows) or .so (Unix/Linux) file, containing the global
         variables to be initialized.
    """

    # Data Ready Signals
    # ------------------------------------------------
    lib.VeAPI_b_PackCurr_DR = 1
    lib.VaAPI_b_CellVolts_DR = [1] * size(lib.VaAPI_b_CellVolts_DR)
    lib.VaAPI_b_TempSnsrs_DR = [1] * size(lib.VaAPI_b_TempSnsrs_DR)
    lib.VeAPI_b_MinTempSnsr_DR = 1
    lib.VeAPI_b_MaxTempSnsr_DR = 1
    lib.VeAPI_b_ChgPackCapcty_DR = 1
    lib.VeAPI_b_PackSOC_DR = 1

    # NVM Initialization
    # ------------------------------------------------
    lib.VeAFC_b_ControllerWakeUp = 0
    lib.VeAFC_b_Initialized = 0
    lib.VeAPI_b_EVSEChgStatus = 1
    lib.VeAPI_I_PackCurr = 1

    lib.fs_API_SetInputsAFC(
        lib.VaAPI_Cmp_NVMRegion,
        lib.VaAPI_Cmp_NVMLoggingRegion,
        lib.VeAPI_I_PackCurr,
        lib.VeAPI_b_PackCurr_DR,
        lib.VaAPI_U_CellVolts,
        lib.VaAPI_b_CellVolts_DR,
        lib.VaAPI_T_TempSnsrs,
        lib.VaAPI_b_TempSnsrs_DR,
        lib.VeAPI_T_MinTempSnsr,
        lib.VeAPI_b_MinTempSnsr_DR,
        lib.VeAPI_T_MaxTempSnsr,
        lib.VeAPI_b_MaxTempSnsr_DR,
        lib.VeAPI_Cap_ChgPackCapcty,
        lib.VeAPI_b_ChgPackCapcty_DR,
        lib.VeAPI_Pct_PackSOC,
        lib.VeAPI_b_PackSOC_DR,
        lib.VeAPI_b_EVSEChgStatus,
        ffi.addressof(lib, "VaAFC_Cmp_CTE_Info"),
        ffi.addressof(lib, "VeAFC_e_ErrorFlags"),
        ffi.addressof(lib, "VeAFC_I_ChgPackCurr"),
        ffi.addressof(lib, "VeAFC_U_ChgPackVolt"),
        ffi.addressof(lib, "VeAFC_b_ChgCompletionFlag"),
        ffi.addressof(lib, "VeAFC_b_ExtremeAgingFlag"),
        ffi.addressof(lib, "VeAFC_b_AbnormalAgingFlag"),
        ffi.addressof(lib, "VeAFC_b_EarlyWarningAgingFlag"),
        ffi.addressof(lib, "VeAFC_b_EOLFlag"),
        ffi.addressof(lib, "VeAFC_b_SOCImbalanceFlag"),
    )

    lib.f_AFC_NVMInit()
    lib.AFC_NVMLoggingInit()

    # Calculation
    # ------------------------------------------------
    lib.s_AFC_Calc.VeAFC_e_QNS_State = 0
    lib.s_AFC_Calc.VeAFC_Cnt_PresentStgNum = 0
    lib.s_AFC_Calc.VeAFC_I_CV_Curr = lib.s_AFC_Param.KeAFC_I_CV_ChgCurr
    lib.s_AFC_Calc.VaAFC_b_ValidSampleFlag = [0] * size(
        lib.s_AFC_Calc.VaAFC_b_ValidSampleFlag
    )
    lib.s_AFC_Calc.VaAFC_U_SampleCellVolt = [0] * size(
        lib.s_AFC_Calc.VaAFC_U_SampleCellVolt
    )

    lib.VeAPI_T_MinTempSnsr = 350
    lib.VeAPI_T_MaxTempSnsr = 565


    lib.s_AFC_Calc.VeAFC_T_StdU_RefCellTemp = 350.0 / 10.0

    # Customer Inputs
    # ------------------------------------------------
    lib.KeINP_n_MaxNumCells = 192
    lib.KeINP_n_MaxNumTempSnsrs = 18
    lib.KaINP_i_Temp2CellIdx = [i // 12 for i in range(192)]

    lib.VeAPI_Pct_PackSOC = 5000
    lib.VeAPI_Cap_ChgPackCapcty = 120600

    random.seed(44)
    noise_mV = [random.uniform(-100, 100) for _ in range(size(lib.VaAPI_U_CellVolts))]
    lib.VaAPI_U_CellVolts = [3200 + int(noise_mV[i]) for i in range(size(lib.VaAPI_U_CellVolts))]

    # lib.VaAPI_U_CellVolts = [3200] * size(lib.VaAPI_U_CellVolts)

    lib.VaAPI_T_TempSnsrs = [-150 + i * 50 for i in range(size(lib.VaAPI_T_TempSnsrs) - 2)]
    lib.VaAPI_T_TempSnsrs[size(lib.VaAPI_T_TempSnsrs) - 2] = min(list(lib.VaAPI_T_TempSnsrs))
    lib.VaAPI_T_TempSnsrs[size(lib.VaAPI_T_TempSnsrs) - 1] = max(list(lib.VaAPI_T_TempSnsrs))

    # lib.VaAPI_T_TempSnsrs = [-100 + i * 50 for i in range(size(lib.VaAPI_T_TempSnsrs))]

    # lib.VaAPI_T_TempSnsrs = [350] * size(lib.VaAPI_T_TempSnsrs)

    lib.VeAPI_I_PackCurr = 500

    # Customer Outputs
    # ------------------------------------------------
    lib.VeAFC_e_ErrorFlags = 0
    lib.VeAFC_I_ChgPackCurr = 0
    lib.VeAFC_U_ChgPackVolt = 0
    lib.VeAFC_b_ChgCompletionFlag = 0

    # OCV vs. SOC
    # ------------------------------------------------
    lib.KaLIB_U_OCVAxis = [
        2583,
        2636,
        2682,
        2721,
        2756,
        2786,
        2814,
        2840,
        2885,
        2905,
        2940,
        2969,
        2995,
        3019,
        3040,
        3060,
        3087,
        3111,
        3139,
        3164,
        3187,
        3228,
        3271,
        3306,
        3335,
        3355,
        3370,
        3379,
        3396,
        3437,
        3497,
        3534,
        3565,
        3597,
        3665,
        3685,
        3704,
        3727,
        3754,
        3772,
        3815,
        3845,
        3870,
        3891,
        3933,
        3952,
        3976,
        4028,
        4048,
        4060,
        4068,
        4074,
        4088,
        4097,
        4106,
        4121,
        4140,
        4151,
        4165,
        4180,
        4195,
    ]

    lib.KaLIB_Pct_SOCAxis = [
        0,
        10,
        20,
        30,
        40,
        50,
        60,
        70,
        90,
        100,
        120,
        140,
        160,
        180,
        200,
        220,
        250,
        280,
        320,
        360,
        400,
        480,
        580,
        670,
        760,
        840,
        910,
        960,
        1090,
        1520,
        2000,
        2350,
        2710,
        3120,
        4210,
        4490,
        4730,
        4970,
        5230,
        5380,
        5690,
        5970,
        6240,
        6500,
        7130,
        7370,
        7610,
        8080,
        8290,
        8440,
        8590,
        8750,
        9270,
        9440,
        9570,
        9700,
        9810,
        9860,
        9910,
        9960,
        10000
    ]

    # NVM
    # ------------------------------------------------
    size_row, size_col = size(lib.s_AFC_Track.NtAFC_Cnt_CPVCorrIdx)
    lib.s_AFC_Track.NtAFC_Cnt_CPVCorrIdx = [[0] * size_col for _ in range(size_row)]

    size_row, size_col = size(lib.s_AFC_Track.NtAFC_U_RefCellVolt)
    lib.s_AFC_Track.NtAFC_U_RefCellVolt = [[0] * size_col for _ in range(size_row)]

    lib.s_AFC_Calc.VaAFC_Cnt_CPVCorrIdx = [0] * size(
        lib.s_AFC_Calc.VaAFC_Cnt_CPVCorrIdx
    )
    lib.s_AFC_Calc.VaAFC_U_RefCellVolt = [0] * size(lib.s_AFC_Calc.VaAFC_U_RefCellVolt)

    # Parameters/Calibrations, based on Volvo battery cell characterization
    # ------------------------------------------------
    lib.sAFC_P.Ve_U_CVFloatCellVolt = 4200
    lib.sAFC_P.Ve_U_SafetyMaxVolt = 4200

    lib.s_AFC_Param.KeAFC_U_CV_RatedChgCellVolt = 4200
    lib.s_AFC_Param.KeAFC_I_CV_ChgCurr = 25200

    lib.s_AFC_Param.KeAFC_I_CV_ChgStepCurr = 500

    lib.s_AFC_Param.KaAFC_Pct_Stg_SOC = [
        1390,
        2110,
        2660,
        3220,
        3770,
        4330,
        4880,
        5400,
        5890,
        6360,
        6780,
        7160,
        7490,
        7770,
        7860,
        8580,
        9010,
        9310,
        9530,
        9700,
    ]

    lib.s_AFC_Param.KaAFC_I_Stg_ChgMaxCurr = [  # mA
        331600,
        331600,
        331600,
        331600,
        331600,
        331600,
        331600,
        331600,
        319300,
        310900,
        284600,
        254000,
        221100,
        187700,
        155400,
        94200,
        62000,
        46000,
        36200,
        30200,
    ]

    lib.s_AFC_Param.KaAFC_I_Stg_ChgMinCurr = [  # mA
        193600,
        193600,
        193600,
        193600,
        193600,
        193600,
        193600,
        193600,
        188200,
        182100,
        167300,
        150500,
        126800,
        107200,
        88700,
        77700,
        55000,
        40000,
        31200,
        25200,
    ]

    lib.s_AFC_Param.KaAFC_I_Stg_ChgStepCurr = [  # mA
        6000,
        6000,
        6000,
        6000,
        6000,
        6000,
        6000,
        6000,
        5700,
        5600,
        5100,
        4500,
        4100,
        3500,
        2900,
        1100,
        700,
        600,
        500,
        500,
    ]

    lib.s_AFC_Param.KaAFC_U_Stg_RefStartCellVolt = [  # mV
        3935,
        3938,
        4003,
        4041,
        4072,
        4105,
        4140,
        4164,
        4175,
        4185,
        4181,
        4177,
        4174,
        4182,
        4174,
        4197,
        4197,
        4197,
        4200,
        4203,
    ]

    lib.s_AFC_Param.KaAFC_U_Stg_RefBandCellVolt = [4] * size(
        lib.s_AFC_Param.KaAFC_U_Stg_RefBandCellVolt
    )

    lib.s_AFC_Param.KaAFC_U_Stg_SADCellLim = [
        4115,
        4018,
        4088,
        4112,
        4143,
        4171,
        4206,
        4231,
        4238,
        4241,
        4242,
        4241,
        4242,
        4243,
        4243,
        4240,
        4240,
        4240,
        4240,
        4240,
    ]

    lib.s_AFC_Param.KeAFC_T_CPV_MaxTempLim = 570
    lib.s_AFC_Param.KeAFC_T_CPV_MinTempLim = -100
    lib.s_AFC_Param.KeAFC_T_RefTemp = 300
    lib.s_AFC_Param.KeAFC_k_Coeff_a = 0.0002147459
    lib.s_AFC_Param.KeAFC_k_Coeff_b = -0.02560036
    lib.s_AFC_Param.KeAFC_k_Coeff_c = 0.000003785433
    lib.s_AFC_Param.KeAFC_k_Coeff_d = 0.5011954
    lib.s_AFC_Param.KeAFC_k_Coeff_e = 0.0088585
    lib.s_AFC_Param.KeAFC_k_Coeff_f = 0.5413935
    lib.s_AFC_Param.KeAFC_k_Coeff_g = -0.0128804
    lib.s_AFC_Param.KeAFC_k_Coeff_h = 1.3

    # Unused variables (commented for possibility of future implementations)
    # ------------------------------------------------
    # lib.g_num_temps = 4
    # lib.adc_VOLT_STACK = sum(lib.VaAPI_U_CellVolts)
    # lib.VeAPI_T_MaxTempSnsr = 4200
    # lib.adc_VOLT_MIN = 3000

    yield

    clean_dat_files(PROJECT_PATH)




class LogParseResult:
    def __init__(self):
        self.indexes = []
        self.cycle_count = None
        self.stage = None
        self.highest_index = None
        self.temperatures = []

    def set_indexes(self, value):
        self.indexes = value

    def set_cycle_count(self, value):
        self.cycle_count = value

    def set_stage(self, value):
        self.stage = value

    def set_highest_index(self, value):
        self.highest_index = value

    def set_temperatures(self, value):
        self.temperatures = value

    def print_buffer(self):
        print(f"Log:  Indexes : {self.indexes}")
        print(f"Log:  Cycle Count : {self.cycle_count}")
        print(f"Log:  Stage : {self.stage}")
        print(f"Log:  Highest Index : {self.highest_index}")
        print(f"Log:  Temperatures : {self.temperatures}")

def get_num_elements_from_buffer(lib):
    obj = ffi.addressof(lib.AFC_LoggingTrack[0], "Ne_Afc_Logging_Circ_Buff_Handle")
    data_ptr = ffi.new("uint16_t *")
    num_elements_inserted = ffi.cast("unsigned short *", data_ptr)
    #num_elements_inserted = ffi.new("uint16_t *")
    lib.LIB_CircBuffNumElementsInserted(obj, num_elements_inserted)
    return num_elements_inserted[0]


def process_log_buffer(lib, extn=1, write_to_file=False):
    """
    Process the log buffer and extract result, assign to return result data object of LogParseResult
    """
    result = LogParseResult()
    lfilename = f"log_buffer_{extn}.xlsx"
    log_data_fname = join(dirname(_MODULE_PATH), _TIME_BASED_OUTPUT_DATA, lfilename)
    log_data = {
        "Indexes": [],
        "Cycle_Count": [],
        "Stage": [],
        "Highest_index": [],
        "Temperatures": [],
    }

    # Get buffer (logged data) and parse
    obj = ffi.addressof(lib.AFC_LoggingTrack[0], "Ne_Afc_Logging_Circ_Buff_Handle")
    print(f"\nElements Inserted: {get_num_elements_from_buffer(lib)}")
    for i in range(extn):
        ele_addr = ffi.new("uint8_t [18]")
        # Get last logged element
        lib.LIB_CircBuffGetElement(obj, i, ele_addr)
        # Get and compare indexes logged
        result.indexes = [
            ele_addr[3],
            ele_addr[6],
            ele_addr[9],
            ele_addr[12],
            ele_addr[15],
        ]

        # Unpack buffer data
        py_list = ffi.unpack(ele_addr, _TOTAL_BYTES)
        print(py_list)
        #logger.debug(py_list)

        u32_word = int.from_bytes(bytes(py_list[:3]), byteorder="little", signed=False)
        result.cycle_count = 0xFFF & (u32_word >> 12)
        result.stage = 0x3F & (u32_word >> 6);
        result.highest_index = 0x3F & (u32_word >> 0);

        # Extract temperature logged
        result.temperatures = [
            int.from_bytes(py_list[4:6], byteorder="little", signed=True),
            int.from_bytes(py_list[7:9], byteorder="little", signed=True),
            int.from_bytes(py_list[10:12], byteorder="little", signed=True),
            int.from_bytes(py_list[13:15], byteorder="little", signed=True),
            int.from_bytes(py_list[16:18], byteorder="little", signed=True),
        ]
        print("\n\n RESULT \n\n")
        print(f"Warning Flags: {lib.VeAFC_e_ErrorFlags}")
        print(f"Early Flags: {lib.VeAFC_b_EarlyWarningAgingFlag}")
        print(f"Abnormal Flags: {lib.VeAFC_b_AbnormalAgingFlag}")
        print(f"Extreme Flags: {lib.VeAFC_b_ExtremeAgingFlag}")
        result.print_buffer()

        log_data["Indexes"].append(result.indexes)
        log_data["Cycle_Count"].append(result.cycle_count)
        log_data["Stage"].append(result.stage)
        log_data["Highest_index"].append(result.highest_index)
        log_data["Temperatures"].append(result.temperatures)
    if write_to_file:
        pass
        #(log_data, log_data_fname)
    return result



if __name__ == "__main__":
    current_dir = Path(__file__).resolve().parent
    invoke_pytest(current_dir, html=MAKE_HTML)
